// Test generated by RoostGPT for test practice-go-nasacollage using AI Type Azure Open AI and AI Model roost-gpt4-32k

package collage_test

import (
    "testing"
    "collage"
    "runtime"
    "sync"
)

// TestNewBarGraph runs a unit test for NewBarGraph function
func TestNewBarGraph(t *testing.T) {
    size := runtime.NumCPU()
    // concurrent calls
    var wg sync.WaitGroup
    wg.Add(2 * size)
    for i := -size; i < size; i++ {
        go func(val int) {
            defer wg.Done()
            graph := collage.NewBarGraph(val)
            if val <= 0 && len(graph) > 0 {
                t.Errorf("NewBarGraph(%d); got size %d; want %d", val, len(graph), 0)
            }
            
            if val > 0 && len(graph) != val {
                t.Errorf("NewBarGraph(%d) = _=%v, want _=%v", val, len(graph), val)
            }
            
            t.Logf("Successfully completed NewBarGraph(%d)", val)
        }(i)
    }
    wg.Wait()
}

// TestNewBarGraphLarge runs a unit test for NewBarGraph function with large size.
func TestNewBarGraphLarge(t *testing.T) {
    // Large value for size
    val := int(1e6)
    
    // Run function
    graph := collage.NewBarGraph(val)
    
    // Test returned size
    if len(graph) != val {
        t.Errorf("NewBarGraph(%d) = _=%v, want _=%v", val, len(graph), val)
    }
    
    // Log result
    t.Logf("Successfully completed NewBarGraph(%d)", val)
}

// TestNewBarGraphMemory runs memory leak test for NewBarGraph function
func TestNewBarGraphMemory(t *testing.T) {
    // Save initial memory stats
    var m1 runtime.MemStats
    runtime.ReadMemStats(&m1)
    
    // Create barchart and don't use it
    _ = collage.NewBarGraph(1e4) 
    
    // Read memory stats after creating barchart
    var m2 runtime.MemStats
    runtime.ReadMemStats(&m2)
    
    // Check memory difference before and after
    if m2.Alloc <= m1.Alloc {
        t.Errorf("Memory did not increase after calling NewBarGraph")
    } 
    
    // Check if GC works
    runtime.GC()
    
    // Read memory stats after calling GC
    var m3 runtime.MemStats
    runtime.ReadMemStats(&m3)
    
    // Verify if GC was able to clean it up
    if m3.Alloc > m2.Alloc {
        t.Errorf("Memory did not decrease after calling GC")
    }
    
    t.Logf("Successfully completed memory leak test for NewBarGraph(1e4)")
}
