// Test generated by RoostGPT for test practice-go-warriors using AI Type Open AI and AI Model gpt-4


/*
Test Scenario 1: 
Test the Swap function with valid positive integers as input. Expect that the values at the given indices are swapped.

Test Scenario 2: 
Test the Swap function with i and j as the same index. Expect that the array remains the same as the value is swapped with itself.

Test Scenario 3: 
Test the Swap function with i or j index out of range. Expect that an out of range error is returned.

Test Scenario 4: 
Test the Swap function with negative integers as input. Expect that an invalid index error is returned.

Test Scenario 5: 
Test the Swap function with i index greater than j index. Expect that the values at the given indices are swapped.

Test Scenario 6:
Test the Swap function with a large size of MyRune array. Expect that the function can handle the size and swap the values correctly.

Test Scenario 7:
Test the Swap function with MyRune array that contains duplicate elements. Expect that the function works correctly and swaps the values.

Test Scenario 8:
Test the Swap function with an empty MyRune array. Expect that an error is returned indicating that the array is empty.

Test Scenario 9:
Test the Swap function with MyRune array that contains special characters. Expect that the function works correctly and swaps the values.

Test Scenario 10:
Test the Swap function with MyRune array that contains a mix of upper and lower case letters. Expect that the function works correctly and swaps the values.
*/
package anagram

import (
	"testing"
)

type MyRune []rune

func TestSwap(t *testing.T) {
	tests := []struct {
		name    string
		r       MyRune
		i       int
		j       int
		want    MyRune
		wantErr bool
	}{
		{
			name:    "Test Scenario 1",
			r:       MyRune([]rune{'a', 'b', 'c'}),
			i:       0,
			j:       2,
			want:    MyRune([]rune{'c', 'b', 'a'}),
			wantErr: false,
		},
		{
			name:    "Test Scenario 2",
			r:       MyRune([]rune{'a', 'b', 'c'}),
			i:       1,
			j:       1,
			want:    MyRune([]rune{'a', 'b', 'c'}),
			wantErr: false,
		},
		{
			name:    "Test Scenario 3",
			r:       MyRune([]rune{'a', 'b', 'c'}),
			i:       3,
			j:       1,
			wantErr: true,
		},
		{
			name:    "Test Scenario 4",
			r:       MyRune([]rune{'a', 'b', 'c'}),
			i:       -1,
			j:       1,
			wantErr: true,
		},
		{
			name:    "Test Scenario 5",
			r:       MyRune([]rune{'a', 'b', 'c'}),
			i:       2,
			j:       0,
			want:    MyRune([]rune{'c', 'b', 'a'}),
			wantErr: false,
		},
		{
			name:    "Test Scenario 6",
			r:       MyRune([]rune{'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'}),
			i:       0,
			j:       25,
			want:    MyRune([]rune{'z', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'a'}),
			wantErr: false,
		},
		{
			name:    "Test Scenario 7",
			r:       MyRune([]rune{'a', 'b', 'b'}),
			i:       1,
			j:       2,
			want:    MyRune([]rune{'a', 'b', 'b'}),
			wantErr: false,
		},
		{
			name:    "Test Scenario 8",
			r:       MyRune([]rune{}),
			i:       0,
			j:       0,
			wantErr: true,
		},
		{
			name:    "Test Scenario 9",
			r:       MyRune([]rune{'a', '!', 'c'}),
			i:       0,
			j:       1,
			want:    MyRune([]rune{'!', 'a', 'c'}),
			wantErr: false,
		},
		{
			name:    "Test Scenario 10",
			r:       MyRune([]rune{'a', 'B', 'c'}),
			i:       0,
			j:       1,
			want:    MyRune([]rune{'B', 'a', 'c'}),
			wantErr: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			defer func() {
				if r := recover(); r != nil && !tt.wantErr {
					t.Errorf("Test %v - got panic = %v, wantErr = %v", tt.name, r, tt.wantErr)
				}
			}()
			tt.r.Swap(tt.i, tt.j)
			if !tt.wantErr && !equal(tt.r, tt.want) {
				t.Errorf("Test %v - got = %v, want = %v", tt.name, tt.r, tt.want)
			}
		})
	}
}

func equal(a, b MyRune) bool {
	if len(a) != len(b) {
		return false
	}
	for i, v := range a {
		if v != b[i] {
			return false
		}
	}
	return true
}
