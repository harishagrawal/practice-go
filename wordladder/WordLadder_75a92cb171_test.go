// Test generated by RoostGPT for test practice-go using AI Type Open AI and AI Model gpt-4

package wordladder

import (
	"testing"
)

func TestWordLadder(t *testing.T) {
	tests := []struct {
		name string
		from string
		to   string
		dic  []string
		want int
	}{
		{
			name: "Test case 1: Same from and to string",
			from: "test",
			to:   "test",
			dic:  []string{"test", "rest", "nest", "next", "exit"},
			want: 0,
		},
		{
			name: "Test case 2: from and to strings not in dictionary",
			from: "hello",
			to:   "world",
			dic:  []string{"test", "rest", "nest", "next", "exit"},
			want: -1,
		},
		{
			name: "Test case 3: from string in dictionary, to string not in dictionary",
			from: "test",
			to:   "world",
			dic:  []string{"test", "rest", "nest", "next", "exit"},
			want: -1,
		},
		{
			name: "Test case 4: to string in dictionary, from string not in dictionary",
			from: "hello",
			to:   "exit",
			dic:  []string{"test", "rest", "nest", "next", "exit"},
			want: -1,
		},
		{
			name: "Test case 5: from and to strings in dictionary, word ladder exists",
			from: "test",
			to:   "exit",
			dic:  []string{"test", "rest", "nest", "next", "exit"},
			want: 4,
		},
		{
			name: "Test case 6: from and to strings in dictionary, no word ladder",
			from: "test",
			to:   "exit",
			dic:  []string{"test", "rest", "best", "beat", "boat"},
			want: -1,
		},
		{
			name: "Test case 7: Large dictionary array",
			from: "test",
			to:   "exit",
			dic:  largeDic(),
			want: 5,
		},
		{
			name: "Test case 8: Empty dictionary array",
			from: "test",
			to:   "exit",
			dic:  []string{},
			want: -1,
		},
		{
			name: "Test case 9: from and to strings present multiple times in dictionary",
			from: "test",
			to:   "exit",
			dic:  []string{"test", "rest", "nest", "next", "exit", "test", "exit"},
			want: 4,
		},
		{
			name: "Test case 10: from and to strings have different lengths",
			from: "test",
			to:   "exit1",
			dic:  []string{"test", "rest", "nest", "next", "exit"},
			want: -1,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := WordLadder(tt.from, tt.to, tt.dic); got != tt.want {
				t.Errorf("WordLadder() = %v, want %v", got, tt.want)
			}
		})
	}
}

func largeDic() []string {
	return []string{"test", "rest", "nest", "next", "exit", "text", "tent", "bent", "beat", "boat", "boot", "root", "rook", "cook", "cool", "pool", "poll", "pall", "pale", "sale", "sage", "wage", "wane", "wine", "vine", "vino", "veil", "veer", "beer", "beef", "reef", "reeb", "roeb", "robe", "rope", "rape", "rave", "wave", "wade", "made", "mode", "mold", "gold", "golf", "goof", "roof", "rook", "book", "boot", "boat", "beat", "belt", "melt", "meet", "meek", "reek", "rock", "rack", "race", "rare", "rate", "tate", "tape", "type", "tyre", "tire", "tine", "vine", "vino", "vein", "vent", "tent", "tend", "lend", "lens", "less", "mess", "moss", "most", "post", "past", "pact", "fact", "face", "race", "rack", "back", "buck", "duck", "dusk", "desk", "dext", "next", "exit"}
}
